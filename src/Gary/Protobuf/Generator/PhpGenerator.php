<?php

namespace Gary\Protobuf\Generator;

use Gary\Protobuf\Internal\DescriptorBuilder;
use Gary\Protobuf\Internal\FieldDescriptor;
use Gary\Protobuf\Internal\FileDescriptor;
use Google\Protobuf\Internal\CodeGeneratorRequest;
use Google\Protobuf\Internal\CodeGeneratorResponse;
use Google\Protobuf\Internal\CodeGeneratorResponse_File;
use Gary\Protobuf\Internal\Descriptor;
use Gary\Protobuf\Internal\EnumDescriptor;
use Google\Protobuf\Internal\EnumValueDescriptorProto;
use Google\Protobuf\Internal\FileDescriptorProto;
use Google\Protobuf\Internal\FileDescriptorSet;
use Google\Protobuf\Internal\GPBType;

class PhpGenerator
{
    const CLASS_NAME_SEPARATOR = '_';
    const PHP_NAMESPACE_SEPARATOR = '\\';
    const PB_NAMESPACE_SEPARATOR = '.';

    const TAB = '    ';
    const EOL = PHP_EOL;

    /** @var  FileDescriptor[] */
    private $fileDescriptors;
    /**
     * @var CodeGeneratorResponse_File[]
     */
    private $responseFiles = [];
    private $customArguments;

    private function generateClass($shortName, $namespace, $content)
    {
        $file = new CodeGeneratorResponse_File();
        $file->setName($this->getClassFilename($shortName, $namespace));
        $file->setContent('<?php' . PHP_EOL . $content);
        $this->responseFiles[] = $file;
    }

    private function generateClassWithFullName($name, $content)
    {
        $file = new CodeGeneratorResponse_File();
        $path = str_replace(
            '\\',
            '/',
            $name
        );
        $file->setName($path . ".php");
        $file->setContent('<?php' . PHP_EOL . $content);
        $this->responseFiles[] = $file;
    }


    /**
     * @param CodeGeneratorRequest $request
     *
     * @return CodeGeneratorResponse
     */
    public function generate(CodeGeneratorRequest $request)
    {

        $this->customArguments = array();
        $parameter = $request->getParameter();
        if ($parameter) {
            parse_str($parameter, $this->customArguments);
        }


        $this->genMetadata($request);

        $this->fileDescriptors = DescriptorBuilder::getBuilder()->getFileDescriptors($request->getProtoFile()->getIterator());
        $fileDescriptors = $this->fileDescriptors;
        foreach ($fileDescriptors as $i => $fileDescriptor) {
            $this->_generateFiles($fileDescriptor);
        }

        $response = new CodeGeneratorResponse();
        $response->setFile($this->responseFiles);
        return $response;
    }

    private function getClassFilename($className, $namespaceName)
    {
        if ($namespaceName) {
            $baseName = str_replace(
                PhpGenerator::PHP_NAMESPACE_SEPARATOR,
                DIRECTORY_SEPARATOR,
                $namespaceName . PhpGenerator::PHP_NAMESPACE_SEPARATOR . $className
            );
        } else {
            $baseName = $className;
        }
        return $baseName . '.php';
    }

    private function genMetadata(CodeGeneratorRequest $request)
    {

        /** @var FileDescriptorProto $proto */
        foreach ($request->getProtoFile() as $proto) {
            $proto = $request->getProtoFile()[0];

            // clone proto to avoid affecting other logic using the source_code_info
            $proto = clone $proto;
            $proto->setSourceCodeInfo(null);

            $p = new FileDescriptorSet();
            $p->getFile()[] = $proto;

            $buffer = new CodeStringBuffer(self::TAB, self::EOL);
            $filename = $proto->getName();
            $filenameNoExt = preg_replace('/(.*)(\.[\w\d]+)$/', '$1', $proto->getName()); // file name without suffix
            $filenameParts = array_map('ucfirst', explode('/', $filenameNoExt));
            array_unshift($filenameParts, 'GPBMetadata');
            $shortClassName = $filenameParts[count($filenameParts) - 1];
            array_pop($filenameParts);
            $nameSpace = implode("\\", $filenameParts);


            $binary = $p->serializeToString();

            $str = <<<TAG
# Generated by the php-protobuf-generator.  DO NOT EDIT!
# source: $filename

namespace $nameSpace;

class $shortClassName
{
    public static \$is_initialized = false;

    public static function initOnce() {
        \$pool = \Google\Protobuf\Internal\DescriptorPool::getGeneratedPool();

        if (static::\$is_initialized == true) {
          return;
        }
TAG;
            $buffer->append($str);
            $buffer->incrIndentation(2);
            $buffer->append("\$pool->internalAddGeneratedFile(hex2bin(");
            $hex = bin2hex($binary);
            $hexArr = str_split($hex, 60);
            $hexRes = implode("\" . \n            \"", $hexArr);
            $buffer->append('    "' . $hexRes . '"', true);
            $buffer->append("));");
            $buffer->append("static::\$is_initialized = true;");
            $buffer->decrIndentation();
            $buffer->append("}");
            $buffer->decrIndentation();
            $buffer->append("}");
            $this->generateClass($shortClassName, $nameSpace, $buffer->__toString());
        }

    }

    /**
     * @param FileDescriptor $file
     *
     * @return CommentStringBuffer
     */
    private function _createFileComment(FileDescriptor $file)
    {
        $comment = new CommentStringBuffer(self::TAB, self::EOL);
        $date = strftime("%Y-%m-%d %H:%M:%S");
        $comment->append('Auto generated from ' . $file->getName() . ' at ' . $date);

        if ($file->getPackage()) {
            $comment->newline()
                ->append('package: ' . $file->getPackage());
        }
        return $comment;
    }

    /**
     * @param FileDescriptor $file
     *
     */
    private function _generateFiles($file)
    {
        foreach ($file->getEnumType() as $descriptor) {
            $this->_createEnum($descriptor, $file);
        }

        /** @var Descriptor $descriptor */
        foreach ($file->getMessageType() as $i => $descriptor) {
            $this->_createClass($descriptor, $file);
        }
    }

    /**
     * @param Descriptor     $descriptor
     * @param FileDescriptor $file
     *
     * @throws \Exception
     */
    private function _createClass(
        Descriptor $descriptor, FileDescriptor $file)
    {
        foreach ($descriptor->getEnumType() as $enum) {
            $this->_createEnum($enum, $file);
        }

        /** @var Descriptor $nested */
        foreach ($descriptor->getNestedType() as $i => $nested) {
            if (!$nested->isMapEntry()) {
                $this->_createClass($nested, $file);
            }
        }

        /**
         * namespace & use
         */
        $buffer = new CodeStringBuffer(self::TAB, self::EOL);
        $buffer->append($this->_createFileComment($file));
        $buffer->newline();

        $namespaceName = $this->_createNamespaceName($descriptor);
        if ($namespaceName) {
            $buffer->append('namespace ' . $namespaceName . ';');
        }
        $buffer->append('use Google\Protobuf\Internal\GPBType;');
        $buffer->append('use Google\Protobuf\Internal\RepeatedField;');
        $buffer->append('use Google\Protobuf\Internal\GPBUtil;');
        $buffer->newline();

        /**
         * class comment
         */
        $comment = new CommentStringBuffer(self::TAB, self::EOL);
        $path = $this->_createEmbeddedMessagePath($descriptor);
        if ($path) {
            $comment->append($descriptor->getFullName() . ' message embedded in ' . $path . ' message');
        } else {
            $comment->append($descriptor->getFullName() . ' message');
        }


        $location = $file->getSourceCodeLocationForPath($descriptor->getSourceCodePath());
        if (!$location) {
            throw  new \Exception("cannot find source code location:" . $descriptor->getFullName());
        }
        if ($location->getLeadingComments()) {
            $comment->append($location->getLeadingComments());
        }
        if ($location->getTrailingComments()) {
            $comment->append($location->getTrailingComments());
        }
        $buffer->append($comment);

        /**
         * class name
         */
        $fullName = $this->_createClassName($descriptor);
        $shortName = $this->getClassShortName($fullName);
        $buffer->append('class ' . $shortName . ' extends \Google\Protobuf\Internal\Message')
            ->append('{')
            ->incrIndentation();

        $this->_createClassConstructor($buffer, $file);
        $this->_createClassBody($descriptor->getField(), $buffer, $file);

        $buffer->decrIndentation()
            ->append('}');

        $this->generateClass($shortName, $namespaceName, $buffer);
    }

    /**
     * @param EnumDescriptor $descriptor
     * @param                $file
     *
     */
    private function _createEnum(
        EnumDescriptor $descriptor, FileDescriptor $file
    )
    {
        $buffer = new CodeStringBuffer(self::TAB, self::EOL);
        $buffer->append($this->_createFileComment($file));
        $buffer->newline();

        $className = $descriptor->getClass();
        $shortName = $this->getClassShortName($className);
        $namespaceName = $this->_createNamespaceName($descriptor);
        if ($namespaceName) {
            $buffer->append('namespace ' . $namespaceName . ";");
        } else {
//            $buffer->append('namespace {');
        }
        $buffer->newline();

        $comment = new CommentStringBuffer(self::TAB, self::EOL);
        $comment->alignWithBuffer($buffer);
        $path = $this->_createEmbeddedMessagePath($descriptor);
        if ($path) {
            $comment->append($descriptor->getClass() . ' enum embedded in ' . $path . ' message');
        } else {
            $comment->append($descriptor->getClass() . ' enum');
        }

        $buffer->append($comment);

        $buffer->append('final class ' . $shortName)
            ->append('{')
            ->incrIndentation();

        $this->_createEnumClassDefinition($descriptor->values(), $buffer);

        $buffer->decrIndentation()
            ->append('}');

//        $buffer->append('}');

        $this->generateClassWithFullName($className, $buffer);
    }

    /**
     * @param Descriptor|EnumDescriptor $descriptor
     *
     * @return null|string
     */
    private function _createNamespaceName($descriptor)
    {
        if (isset($this->customArguments['options']['namespace'])) {
            return $this->customArguments['options']['namespace'];
        }

        $t = $descriptor->getClass();
        $t = explode("\\", $t);
        array_pop($t);
        $name = implode("\\", $t);
        return $name;
    }

    /**
     * @param Descriptor $descriptor
     *
     * @return string
     */
    private function _createClassName($descriptor)
    {
        return $descriptor->getClass();
    }


    private function getClassShortName($fullName)
    {
        $n = explode("\\", $fullName);
        $n = array_pop($n);
        return $n;
    }

    /**
     * Creates embedded message path composed of ancestor messages
     * separated by slash "/". If message has no ancestor returns empty string.
     *
     * @param Descriptor|EnumDescriptor $descriptor
     *
     * @return string
     */
    private function _createEmbeddedMessagePath($descriptor)
    {
        $containing = $descriptor->getContaining();
        $path = array();

        while ($containing && !$containing instanceof FileDescriptor) {
            /**
             * @var Descriptor $containing
             */
            $path[] = $containing->getFullName();
            $containing = $containing->getContaining();
        }

        array_reverse($path);

        return implode("/", $path);
    }

    /**
     * @param FieldDescriptor[] $fields
     * @param CodeStringBuffer  $buffer
     * @param                   $file
     */
    private function _createClassBody(array $fields, CodeStringBuffer $buffer, FileDescriptor $file)
    {
        foreach ($fields as $i => $field) {
            $comment = new CommentStringBuffer(self::TAB, self::EOL);
            $comment->setIndentLevel($buffer->getIndentLevel());
            $file->getFileContent();

            $location = $file->getSourceCodeLocationForPath($field->getSourceCodePath());
            $span = $location->getSpan();
            $code = $file->codeBySpan($span);
            if ($location->getLeadingComments()) {
                $comment->append($location->getLeadingComments());
                $comment->newline();
            }
            if ($location->getTrailingComments()) {
                $comment->append($location->getTrailingComments());
                $comment->newline();
            }
            $comment->append(sprintf("Generated from protobuf field <code>$code</code>"));
            $buffer->append($comment);
            $buffer->append('private $' . $field->getName() . ';');
        }

        foreach ($fields as $field) {
            $this->_describeSingleField($field, $buffer, $file);
        }
    }

    /**
     * @param FieldDescriptor  $field
     * @param CodeStringBuffer $buffer
     * @param FileDescriptor   $file
     */
    private function _describeSingleField(FieldDescriptor $field, CodeStringBuffer $buffer, FileDescriptor $file)
    {
        $phpType = $field->getPhpType();
        if ($phpType != 'object') {
            $typeName = $phpType;
        } else {
            $typeName = '\\' . $field->getMessageType()->getClass();
        }


        $location = $file->getSourceCodeLocationForPath($field->getSourceCodePath());
        $span = $location->getSpan();
        $code = $file->codeBySpan($span);
        $sourceInfo = sprintf("Generated from protobuf field <code>$code</code>");
        $leading = $location->getLeadingComments();
        $trailing = $location->getTrailingComments();

        /**
         * Set
         */
        if ($field->isMap()) {
            $retType = '\Google\Protobuf\Internal\MapField';
        } else if ($field->isRepeated()) {
            $retType = $typeName . '[]|RepeatedField';
        } else {
            $retType = $typeName;
        }
        $comment = new CommentStringBuffer(self::TAB, self::EOL);
        $comment->setIndentLevel($buffer->getIndentLevel());
        if ($leading) {
            $comment->append($leading);
            $comment->newline();
        }
        if ($trailing) {
            $comment->append($trailing);
            $comment->newline();
        }
        $comment->append($sourceInfo)
            ->appendParam(
                'param',
                $retType . ' $value'
            )
            ->appendParam('return', '$this');

        if ($field->isMap()) {
            $valueField = $field->getMessageType()->getFieldByNumber(2);
            if ($valueField->getType() == GPBType::MESSAGE) {
                $tmpType = '\\' . $valueField->getMessageType()->getClass();
            } else {
                $tmpType = 'GPBType::' . strtoupper($field->getMessageType()->getFieldByNumber(1)->getSimpleTypeName());
            }
            $checkLine = sprintf('$value = GPBUtil::checkMapField($value, GPBType::%s, %s);',
                strtoupper($field->getMessageType()->getFieldByNumber(1)->getSimpleTypeName()),
                $tmpType
            );
        } else if ($field->isRepeated()) {
            if ($field->getType() == GPBType::MESSAGE) {
                $checkLine = sprintf('$value = GPBUtil::checkRepeatedField($value, GPBType::%s, %s::class);',
                    strtoupper($field->getSimpleTypeName()),
                    '\\' . $field->getMessageType()->getClass()
                );
            } else {
                $checkLine = sprintf('$value = GPBUtil::checkRepeatedField($value, GPBType::%s);',
                    strtoupper($field->getSimpleTypeName()));
            }
        } else if ($field->getType() == GPBType::MESSAGE) {
            $checkLine = 'GPBUtil::checkMessage($value, \\' . $field->getMessageType()->getClass() . '::class);';
        } else {
            $simpleTypeName = $field->getSimpleTypeName();
            $simpleTypeName = str_replace("SInt", "Int", $simpleTypeName);
            $simpleTypeName = str_replace("SFixed", "Int", $simpleTypeName);
            $simpleTypeName = str_replace("Fixed", "UInt", $simpleTypeName);
            if ($field->getType() == GPBType::STRING) {
                $checkLine = 'GPBUtil::check' . $simpleTypeName . '($value, true);';
            } else if ($field->getType() == GPBType::BYTES) {
                $checkLine = 'GPBUtil::checkString($value, false);';
            } else {
                $checkLine = 'GPBUtil::check' . $simpleTypeName . '($value);';
            }
        }
        $buffer
            ->append($comment)
            ->append(
                'public function set' . ucfirst($field->getJsonName()) .
                '($value)'
            )
            ->append('{')
            ->incrIndentation()
            ->append($checkLine)
            ->append('$this->' . $field->getName() . ' = $value;')
            ->append(
                'return $this;'
            )
            ->decrIndentation()
            ->append('}');

        /**
         * Getter
         */
        $comment = new CommentStringBuffer(self::TAB, self::EOL);
        $comment->setIndentLevel($buffer->getIndentLevel());
        if ($leading) {
            $comment->append($leading);
            $comment->newline();
        }
        if ($trailing) {
            $comment->append($trailing);
            $comment->newline();
        }
        $comment->append($sourceInfo)
            ->appendParam('return', $retType);

        $buffer->newline()
            ->append($comment)
            ->append('public function get' . ucfirst($field->getJsonName()) . '()')
            ->append('{')
            ->incrIndentation();
        $buffer->append('return ' . '$this->' . $field->getName() . ';');
        $buffer->decrIndentation()
            ->append('}')->newline();
    }

    /**
     * @param EnumValueDescriptorProto[] $enums
     * @param CodeStringBuffer           $buffer
     *
     */
    private function _createEnumClassDefinition(array $enums, CodeStringBuffer $buffer)
    {
        foreach ($enums as $enum) {
            $buffer->append(
                'const ' . $enum->getName() . ' = ' . $enum->getNumber() . ';'
            );
        }

        $buffer->newline();

        $comment = new CommentStringBuffer(self::TAB, self::EOL);
        $comment->alignWithBuffer($buffer);
        $comment->append('Returns defined enum values')
            ->newline()
            ->appendParam('return', 'int[]');

        $buffer->append($comment)
            ->append('public function getEnumValues()')
            ->append('{');

        $buffer->append('return array(', true, 1)
            ->incrIndentation()
            ->incrIndentation();

        foreach ($enums as $enum) {
            $buffer->append('\'' . $enum->getName() . '\' => self::' . $enum->getName() . ',');
        }

        $buffer->decrIndentation()
            ->append(');');

        $buffer->decrIndentation()
            ->append('}');
    }

    /**
     * @param CodeStringBuffer  $buffer
     * @param FileDescriptor    $file
     *
     */
    private function _createClassConstructor(CodeStringBuffer $buffer, $file)
    {

        $buffer->newline();

        $name = preg_replace('/(.*)(\.[\w\d]+)$/', '$1', $file->getName());
        $fileNamespace = implode("\\", array_map('ucfirst', explode('/', $name)));
        $buffer->append('public function __construct()')
            ->append('{')
            ->incrIndentation()
            ->append(sprintf('\GPBMetadata\%s::initOnce();', $fileNamespace))
            ->append('parent::__construct();')
            ->decrIndentation()
            ->append('}')
            ->newline();

        $comment = new CommentStringBuffer(self::TAB, self::EOL);
        $comment->append('Clears message values and sets default ones')
            ->newline()
            ->appendParam('return', 'null');

        $buffer->newline();
    }
}
